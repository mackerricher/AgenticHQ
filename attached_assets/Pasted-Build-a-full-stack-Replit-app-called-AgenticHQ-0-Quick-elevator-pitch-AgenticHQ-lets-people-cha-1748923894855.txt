Build a full-stack Replit app called “AgenticHQ”
0. Quick elevator pitch
“AgenticHQ” lets people chat with an LLM that can plan and execute multi-step workflows made of:

Clients → LLMs (ChatGPT, DeepSeek)

Agents → GitHub & Google-Mailer, each exposing fetch-based tools

Sub-Agents → File-Creator (local, no fetch)

The user adds keys in a Settings UI, types natural-language requests, the LLM responds with a JSON plan, the server runs it step-by-step, and the result is fed back to the LLM for a friendly answer.

1. Tech stack
Layer	Choice
Front-end	React + Vite + TypeScript + Tailwind CSS + shadcn/ui
Back-end	Node 18 · Express + TypeScript
Database	Prisma ORM · SQLite (file-based; perfect for Replit)
Secrets	Encrypted in SQLite (see § 5)
CI / Tests	Vitest · SuperTest · React Testing Library
Dev UX	.replit runs npm run dev; replit.nix pins Node 18

2. Core domain objects
Layer	Class / Model	Responsibilities
Clients	Client	Stores LLM provider name ("openai" / "deepseek") + encrypted API key.
Agents	GitHubAgent	Tools: createRepo(name, description), addFile(repo, path, content)
GoogleMailerAgent	Tool: sendEmail(to, subject, body)
Sub-Agents	FileCreatorSubAgent	Tool: createMarkdown(text) → returns local path
Plans	Plan	Ordered list of tool invocations + arguments generated by the LLM.

3. Functional flow
Chat UI → user sends a message.

LLM service receives: user prompt + list of every available tool (Agents + attached Sub-Agents).

LLM returns a JSON plan, e.g.

json
Copy
Edit
{
  "steps": [
    { "tool": "GitHub.createRepo", "args": { "name": "HelloHQ", "description": "Demo" } },
    { "tool": "FileCreator.createMarkdown", "args": { "text": "## HelloHQ\n(c) 2025" } },
    { "tool": "GitHub.addFile", "args": { "repo": "HelloHQ", "path": "README.md", "contentRef": 1 } },
    { "tool": "GoogleMailer.sendEmail", "args": { "to": "me@example.com", "subject": "Repo Ready", "body": "✨ All done!" } }
  ]
}
Plan-Runner executes each step, resolves contentRef pointers, captures output/errors, streams progress via SSE.

Aggregated result is sent back to the LLM → LLM returns a final, human-readable answer → displayed in chat.

Errors pop toasted notifications; the timeline highlights failed steps.

4. Gen Alpha UI requirements
Area	Details
Layout	Two-pane on ≥ 768 px: Sidebar (settings + theme) & Main (chat + plan timeline). Mobile collapses to tabs.
Theme toggle	Light / Dark switch (navbar); preference in localStorage.
Colors & fonts	Tailwind custom palette: bubble-gum pink + pastel gradients (from-pink-300 via-blue-200 to-violet-200). Headings use “Lilita One” (playful); body uses a classy serif.
Decor & motion	Glitter SVG overlays, rounded-xl cards, subtle drop-shadows. Framer-motion for modals, message send, theme shifts.
Ethics ribbon	Persistent footer link “Eco pledge” → /eco-pledge page describing recyclable hosting & carbon offsets.
Error handling	<Toast> (shadcn/ui) shows summary + copy-stacktrace button.

5. 🔐 Secret-storage strategy (replaces “Replit Secrets”)
Concern	Solution
Mutable keys	Prisma model Secret persisted in SQLite.
Encryption	AES-256-GCM via Prisma middleware. Only the ciphertext is stored.
Master key	process.env.MASTER_SECRET lives in Replit’s Secrets tab. (Generate with openssl rand -hex 32.)
Schema	prisma model Secret { id Int @id @default(autoincrement()) provider String key Bytes // encrypted blob createdAt DateTime @default(now()) updatedAt DateTime @updatedAt }
Service API	secretService.ts ⇒ getKey(provider), setKey(provider, rawKey), deleteKey(provider) with LRU cache.
Client/server flow	UI POSTs raw key once; server encrypts & stores. GET returns only {hasKey:true, updatedAt}.
Fallback	If DB lacks a key, tool runners may fall back to process.env.GITHUB_PAT, OPENAI_KEY, etc.
Rotation / deletion	DELETE wipes DB + cache; next tool call fails cleanly → toast.
Tests	Use in-memory SQLite + fake MASTER_SECRET.

6. Configuration pages (Sidebar links)
Path	What users can do
/settings/llm	Add · edit · delete keys for OpenAI & DeepSeek; choose default provider.
/settings/github	Add · edit · delete GitHub Personal Access Token; display required scopes.
/settings/gmail	Add · edit · delete Gmail OAuth credentials; link help doc.

7. REST / SSE API routes
Method	Route	Purpose
POST	/api/chat	{clientId, userMessage} → returns {assistantMessage}
POST	/api/plan	{planJson} → streams step output via SSE
CRUD	/api/keys/:provider	Manage encrypted secrets (provider = openai, deepseek, github, gmail)

8. Libraries to install
bash
Copy
Edit
npm i express cors openai deepseek-js @octokit/rest googleapis
npm i prisma @prisma/client
npm i -D typescript ts-node-dev vite react react-dom tailwindcss postcss autoprefixer
npm i -D vitest supertest @testing-library/react
(Replit template: choose “Node.js with React (Vite)” and add Prisma CLI.)

9. File & folder structure
swift
Copy
Edit
.prisma/schema.prisma
/src/server/index.ts
/src/server/routes/*.ts
/src/server/agents/{github,mailer,fileCreator}.ts
/src/server/llm/*.ts
/src/server/planRunner.ts
/src/server/secretService.ts
/src/client/main.tsx
/src/client/components/{Chat,Sidebar,PlanTimeline,Toast,ThemeToggle}.tsx
/src/client/pages/settings/{Llm,Github,Gmail}.tsx
/replit.nix
.env.example
README.md
10. README-generated checklist
Quick start:

bash
Copy
Edit
npm i  
npx prisma db push  
echo 'MASTER_SECRET=$(openssl rand -hex 32)' >> .env  
npm run dev
Explainer: How AgenticHQ’s JSON plan schema works.

Screenshots (light & dark) highlighting Gen Alpha look.

“Secrets & Encryption” paragraph (cite AES-256-GCM + master key).

“Eco Pledge” section.

11. Acceptance criteria
Runs with one click on Replit.

User can store / rotate all four keys via the UI; DB shows hasKey:true.

Chat prompt “Spin up a repo, write a README, and email me the link” succeeds end-to-end.

Light/dark toggle and pastel-pink gradient UI match Gen Alpha spec.

Unit-test coverage ≥ 80 %.